В рамках практической работы был разработан консольный инструмент для анализа и визуализации графа зависимостей пакетов, ориентированный на экосистему Python (pip). В соответствии с требованиями задания, при реализации не использовались готовые менеджеры пакетов и сторонние библиотеки для получения зависимостей — вся логика построена с нуля. Инструмент поддерживает как тестовый режим (для отладки и демонстрации), так и упрощённую эмуляцию работы с реальными пакетами. Конфигурация осуществляется через JSON-файл, что обеспечивает гибкость и удобство настройки без изменения исходного кода.

На первом этапе была реализована минимальная версия приложения — CLI-интерфейс, способный считывать параметры из конфигурационного файла config.json. В число обязательных параметров входят: имя анализируемого пакета, URL или путь к источнику данных, флаг тестового режима и максимальная глубина анализа. При старте программа выводит все параметры в формате «ключ: значение», а также выполняет строгую валидацию: проверяет наличие всех полей, корректность типов (например, test_mode должен быть булевым, max_depth — неотрицательным целым числом) и корректность JSON-структуры. В случае ошибки выводится понятное сообщение, и приложение завершается в штатном режиме.

На втором этапе добавлена логика сбора данных о прямых зависимостях. В тестовом режиме зависимости считываются из локального JSON-файла (test_repo.json), где каждый пакет представлен как ключ, а его зависимости — как список строк (например, "A": ["B", "C"]). В реальном режиме используется встроенная заглушка — словарь с предопределёнными зависимостями для популярных пакетов (например, requests зависит от urllib3 и chardet). Такой подход полностью соответствует ограничению ТЗ: запрещено использовать внешние API, парсинг PyPI или вызовы pip, поэтому получение данных сведено к детерминированной, заранее известной модели. Результат — вывод списка прямых зависимостей заданного пакета.

На третьем этапе реализовано построение полного графа зависимостей с учётом транзитивности, то есть анализируются не только прямые, но и косвенные зависимости (например, если A → B, а B → C, то C также считается зависимостью A). Для обхода графа используется алгоритм поиска в глубину (DFS) без рекурсии — с явным стеком, в который помещаются кортежи вида (пакет, текущая_глубина). Это позволяет избежать переполнения стека вызовов при больших графах и обеспечивает детерминированное поведение. Учитывается ограничение на максимальную глубину: узлы, расположенные глубже указанного уровня, не обрабатываются. Также реализована защита от циклических зависимостей — через множество посещённых узлов, что гарантирует завершение работы даже при наличии петель вида A → B → A. Поддержка тестового режима позволяет легко проверить работу алгоритма на графах с различной топологией: деревьями, циклами, изолированными компонентами.

Четвёртый этап посвящён дополнительной операции — поиску обратных зависимостей, то есть таких пакетов, которые зависят от заданного. Например, если A → B и C → B, то для пакета B обратные зависимости — это A и C. Для этого строится обратный граф: проходом по всем пакетам и их зависимостям формируется новая структура, где для каждого пакета X ведётся список пакетов, ссылающихся на него. Операция выполняется за линейное время относительно размера графа и не требует рекурсивного обхода — в рамках варианта 1 требуется найти только прямые обратные зависимости (без транзитивного расширения), что соответствует формулировке ТЗ. Результат выводится в виде списка имён пакетов.

На пятом, заключительном этапе реализована визуализация графа с использованием языка Mermaid. Программа генерирует текстовое представление графа в формате, совместимом с Mermaid Live Editor (например, graph TD\nA --> B\nA --> C). Вывод производится в консоль в виде блока, ограниченного тройными обратными кавычками — как того требует синтаксис Markdown. Продемонстрированы примеры визуализации для трёх различных пакетов (например, A, B, G), что позволяет увидеть, как структура графа меняется в зависимости от точки входа. Также проведено сравнение с эталонным инструментом pipdeptree. Расхождения объяснены: pipdeptree получает актуальную информацию из установленного окружения, включая версионные ограничения (urllib3>=1.21.1,<3) и условные зависимости, тогда как разработанный инструмент намеренно использует упрощённую модель без версий и опциональных зависимостей — в полном соответствии с требованием ТЗ «готовые средства использовать нельзя». Таким образом, различия не являются ошибками, а отражают сознательное упрощение для учебных целей.

В результате выполнения всех пяти этапов создан автономный, полностью контролируемый инструмент анализа зависимостей, отвечающий всем требованиям задания: поддерживает настраиваемую конфигурацию, корректно обрабатывает циклы и ограничения глубины, реализует как прямой, так и обратный анализ, а также обеспечивает наглядную визуализацию. Приложение может быть использовано как основа для дальнейшего развития — например, добавления поддержки других менеджеров пакетов или интеграции в CI/CD-процессы для обнаружения критических узлов в графе зависимостей.